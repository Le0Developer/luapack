--NO REQUIRE--
-- Source: https://github.com/o080o/reLua  (but got luapacked)
local e,t,a={loaded={},packages={["reParse"]="local e=require(\"reData\")local t=function(...)end local a=e.Stack local o=e.Tree local i=e.CharacterClass local n=i(\"[^]\")getmetatable(n).__tostring=function(h)return\".\"end function addNode(h,r)h.children[1]=h.children[1]:concat(r)return h end function lastNode(h)if h.children[1].val==\"CONCAT\"then return table.remove(h.children[1].children)else local r=table.remove(h.children)table.insert(h.children,o.new())return r end end function newNode(h)return function(r,d)return addNode(r,o.new(h))end end function newRepetition(h)return function(r,d)local l=lastNode(r)return addNode(r,o.new(h,{l}))end end local s={}grammar={}ESC=\"/\"grammar.literal=function(h,r,d)return addNode(h,o.new(d))end grammar.multi={}grammar.multi[\"R\"]=function(h,r)addNode(h,o.new(\"RECURSE\"))r:push(h)return o.new(\"EMPTY\",{o.new()})end grammar[ESC..\"R\"]=newNode(\"RECURSE\")grammar[\".\"]=newNode(n)grammar[\"+\"]=newRepetition(\"PLUS\")grammar[\"-\"]=newRepetition(\"MINUS\")grammar[\"*\"]=newRepetition(\"STAR\")grammar[\"?\"]=newRepetition(\"QUESTION\")grammar[\"[\"]=function(h,r,d)local l=0 local u=false for m in d:gmatch(\".\")do l=l+1 if m==ESC and not u then u=true elseif m==\"]\"and not u then break elseif u then u=false end end local c=i(\"[\"..d:sub(1,l))t(\"New character class:\",c)addNode(h,o.new(c))return h,l end grammar[\"|\"]=function(h,r)local d=o.new(\"EMPTY\",{o.new()})h.children[1]=o.new(\"|\",{h.children[1],d})return d end grammar[\"(\"]=function(h,r,d)if d:sub(1,1)==\"?\"then local l=d:sub(2)for u,c in pairs(grammar.multi)do local m,f l:find(u)if m==1 then c(h,r,d)break end end else local l=o.new(\"CAPTURE\",{o.new()})addNode(h,l)r:push(h)return l end end grammar[\")\"]=function(h,r)return r:pop()end function s.parse(h)local r=o.new(\"ROOT\",{o.new()})local d=r t(\"parsing  \"..h)local l=a.new()local u=false local c=true local m=0 while m<#h do m=m+1 local f=h:sub(m,m)local w=h:sub(m+1)or\"\"t(\"p:\",f,w)if u then u=false if grammar[ESC..f]then r=grammar[ESC..f](r,l)else r=grammar.literal(r,l,f)end elseif f==ESC then u=true else if grammar[f]then r,n=grammar[f](r,l,w)if n then m=m+n end else r=grammar.literal(r,l,f)end end end assert(not l:pop(),\"Regex parse stack is not empty. Possible missing close paren?\")t(d)return d end return s",["__luapack_entry__"]="local e=require(\"reData\")local t=require(\"reParse\")local a=e.DefaultTable local o=e.ListTable local i={}local function n(...)print(...)end local s=0 local h={}h.__index=h function h.new()s=s+1 return setmetatable({id=tostring(s)},h)end function h.__tostring(l)return\"State: \"..l.id end local r={}r.__index=r function r.new()local l={}local u=h.new()l.start=u l.states={}l.states[u]=true l.edges=a(function()return o()end)l=setmetatable(l,r)return l end function r:final()local l={}for u,c in pairs(self.states)do if u.isFinal then table.insert(l,u)end end return l end function r:addEdge(l,u,c)if type(u)==\"table\"and u.isCharacterClass then self.edges[l][\"CLASS\"][u]=c else table.insert(self.edges[l][u],c)end end function r:insert(l)for u,c in pairs(l.states)do self.states[u]=true self.edges[u]=l.edges[u]end return self end function r.concat(l,u)local c=u.start for m,f in pairs(l:final())do f.isFinal=false l:addEdge(f,\"EPSILON\",c)end l:insert(u)return l end function r:addState(l,u,c)local m=h.new()if c then m.isFinal=true end self.states[m]=true if l and u then self:addEdge(l,u,m)end return m end function r:execute(l)self:init(l)for m in l:gmatch(\".\")do if not self:step(m)then break end end local u=false for c,m in pairs(self:final())do if self.curState[m]then u=true break end end local u=self:match()if not u then return u end return self:match():extract(l)end function r:match()local l=self:final()local u for c,m in pairs(l)do local f=self.curState[m]u=compare(f,u)end return u end function r:printMatches()local l=self:match()for u=1,l.nGroups*3,3 do if l[u+1]and l[u+2]then print(\"match: \",(u-1)/3+1,\"[\"..l[u+1]..\":\"..l[u+2]..\"]\",self.input:sub(l[u+1],l[u+2]))end end end local d={}d.__index=d function d.new(...)return setmetatable({nGroups=0},d)end function d.__tostring(l)local u={}table.insert(u,\"Path:\")for c=1,l.nGroups*3,3 do table.insert(u,\"  group:\")table.insert(u,(c-1)/3+1)if l[c+1]then table.insert(u,\" [\")table.insert(u,l[c+1])table.insert(u,\":\")if l[c+2]then table.insert(u,l[c+2])else table.insert(u,\"...\")end table.insert(u,\"]\")else table.insert(u,\" None\")end end return table.concat(u)end function d:extract(l)local u={}for m=1,self.nGroups*3,3 do local f,w,y=self[m+1],self[m+2]if w and f and w>=f then y=string.sub(l,f+1,w)else y=\"\"end table.insert(u,y)end local c={}function c.__tostring(m)local f={}for w,y in ipairs(m)do table.insert(f,y)table.insert(f,\", \")end table.remove(f)return table.concat(f)end return setmetatable(u,c)end function r:init(l)self.steps=0 self.input=l self.curState={}for u,c in pairs(eClosure(self,self.start))do local m=d.new()for w,y in ipairs(c)do y(self,u,\"\",m)end self.curState[u]=m end self.subMatches={}self.partialMatches={}for u,c in pairs(self.curState)do end end function compare(l,u)if not u then return l end local c=math.max(l.nGroups,u.nGroups)for m=1,c*3,3 do assert(l[m]==u[m],\"Mismatched maximality for group\")local f=l[m+0]local w,y=0,0 if l[m+2]then w=l[m+2]-l[m+1]end if u[m+2]then y=u[m+2]-u[m+1]end if w>y then if f then return l else return u end elseif y>w then if f then return u else return l end end end return l end function copy(l)local u=d.new()for c,m in pairs(l)do u[c]=m end return u end function r:step(l)local u={}local c=false self.steps=self.steps+1 function addState(m,f)c=true newstates=eClosure(self,m)for w,y in pairs(newstates)do local p=copy(f)for v,b in ipairs(y)do b(self,w,l,p)end u[w]=compare(p,u[w])end end for m,f in pairs(self.curState)do for w,y in pairs(self.edges[m][\"CLASS\"])do if w[l]then addState(y,f)end end for w,y in pairs(self.edges[m][l])do addState(y,f)end end self.curState=u return c end function r.__tostring(l)return\"NDFA: \"..l.regex end function eClosure(l,u,c)if not l.cache then l.cache=a(function()return o()end)end local m=l.cache.eClosure[u]if m.clean then return m.val else val=eClosure2(l,u,{},{},1)m.val=val m.clean=true return val end end function eClosure2(l,u,c,m,f)local w=l.cache.eClosure[u]local y={}y[u]={}m[u]=f for p,v in pairs(l.edges[u][\"EPSILON\"])do if not m[v]or m[v]>f then eClosure2(l,v,y,m,f+1)end end if u.hit then for p,b in pairs(y)do table.insert(b,1,u.hit)end end for p,b in pairs(y)do c[p]=b end return c end function i.compile(l)local u=t.parse(l)local c={\"One\",\"Two\",\"Three\",\"Four?\"}s=0 local m=buildNDFA(u,{captureNames=c,groupN=0})m.regex=l return m end function startGroup(l,u)return function(m,f,w,y)local c=(l-1)*3+1 y[c]=u y[c+1]=m.steps y[c+2]=nil if y.nGroups<l then y.nGroups=l end end end function stopGroup(l)return function(u,m,f,w)local c=(l-1)*3+1 if w[c+1]then if w.nGroups<l then w.nGroups=l end w[c+2]=u.steps end end end function buildNDFA(l,u)local c={}c.__index=function(m,v)if not v then n(\"nil literal?\")end return function(b)local g=r.new()g:addState(g.start,v,true)return g end end local f=setmetatable({},c)function f.CONCAT(m)local v=nil for b,g in ipairs(m)do if v then v:concat(g)else v=g end end return v end function f.DOT(m)local v=r.new()v:addState(v.start,\"DOT\",true)return v end function f.QUESTION(m,v)local b=r.new()local g=m[1]local k=r.new()b.start.isFinal=true k.start.isFinal=true b:concat(g):concat(k)v.groupN=v.groupN+1 local q=v.groupN b.start.hit=startGroup(q,true)k.start.hit=stopGroup(q)b:addEdge(b.start,\"EPSILON\",k.start)return b end function f.PLUS(m,v)local b=r.new()local g=m[1]local k=r.new()b.start.isFinal=true k.start.isFinal=true local q=g:final()b:concat(g):concat(k)v.groupN=v.groupN+1 local j=v.groupN local x=g.start for z,_ in pairs(q)do b:addEdge(_,\"EPSILON\",x)end b.start.hit=startGroup(j,true)k.start.hit=stopGroup(j)return b end function f.MINUS(m,v)local b=f.STAR(m,v)local g=v.groupN b.start.hit=startGroup(g,false)return b end function f.STAR(m,v)local b=r.new()local g=m[1]local k=r.new()b.start.isFinal=true k.start.isFinal=true local q=g:final()b:concat(g):concat(k)v.groupN=v.groupN+1 local j=v.groupN local x=g.start for z,_ in pairs(q)do b:addEdge(_,\"EPSILON\",x)b:addEdge(x,\"EPSILON\",_)end b.start.hit=startGroup(j,true)k.start.hit=stopGroup(j)return b end f[\"|\"]=function(m)local v=r.new()local b=m[1]local g=m[2]v:insert(b)v:insert(g)v:addEdge(v.start,\"EPSILON\",b.start)v:addEdge(v.start,\"EPSILON\",g.start)return v end function f.ROOT(...)return f.EMPTY(...)end function f.EMPTY(m)if m[1]then return m[1]else return r.new()end end function f.CAPTURE(m,v)local b=r.new()local g=table.remove(v.captureNames,1)v.groupN=v.groupN+1 local k=v.groupN b.start.isFinal=true b.start.captureName=g b.start.hit=startGroup(k,true)local q=m[1]local j=r.new()j.start.isFinal=true j.start.captureName=g j.start.hit=stopGroup(k)b:concat(q):concat(j)return b end local w={}for m,v in pairs(l.children)do local b=buildNDFA(v,u)w[m]=b end if not w then n(\"no children?\")end local y=l.val or\"Empty\"local p=f[y](w,u)return p end return i",["reData"]="local e={}e.__index=e setmetatable(e,e)function e.__call(s,h)local r={}local d={}if type(h)==\"function\"then d.__index=function(s,l)local u=h(l)s[l]=u return u end elseif type(h)==\"table\"then d.__index=function(s,l)local u={}for c,m in pairs(h)do u[c]=m end s[l]=u return u end else d.__index=function(s,l)return h end end return setmetatable(r,d)end local t={}t.__index=t setmetatable(t,t)function t.__call()return e({})end local a={}setmetatable(a,a)function a.__call(s,h)local r=e(false)local d=1 local l=\"\"local u=false local c=false for m in h:sub(2):gmatch(\".\")do d=d+1 if d==2 and m==\"^\"then r=e(true)c=true elseif m==ESC and not u then u=true elseif m==\"]\"and not u then break elseif m==\"-\"and not u and d~=1 and d~=#h then local f=string.sub(h,d+1,d+1)for w=string.byte(l),string.byte(f)do w=string.char(w)r[w]=not c end else r[m]=not c end l=m end r.isCharacterClass=true mt=getmetatable(r)function mt.__tostring(r)local h={}table.insert(h,\"[\")if c then table.insert(h,\"^\")end for m,f in pairs(r)do if m~=\"isCharacterClass\"then table.insert(h,m)end end table.insert(h,\"]\")return table.concat(h)end return r end local o={}o.__index=o function o.new(s,h)local r if h then r={val=s,children=h}else r={val=s,children={}}end setmetatable(r,o)return r end function o.empty(s)if not s.val then return true end return false end function o.concat(s,h)if s:empty()then return h end if h:empty()then return s end local r={}if s.val==\"CONCAT\"then for d,l in ipairs(s.children)do table.insert(r,l)end else table.insert(r,s)end if h.val==\"CONCAT\"then for d,l in ipairs(h.children)do table.insert(r,l)end else table.insert(r,h)end return o.new(\"CONCAT\",r)end function o.print(s,h)local h=h or\"\"local r=tostring(s.val)or\"EMPTY\"print(h..\"->\"..r)for d,l in pairs(s.children)do l:print(h..\"|\")end end function o.__tostring2(s,h,r)local d=tostring(s.val)or\"EMPTY\"for l=1,h do table.insert(r,\"|\")end table.insert(r,\"_>\")table.insert(r,d)table.insert(r,\"\\n\")for l,u in pairs(s.children)do u:__tostring2(h+1,r)end end function o.__tostring(s)local h={}s:__tostring2(0,h)return table.concat(h)end local i={}i.__index=i function i.new()return setmetatable({},i)end function i:push(s)table.insert(self,s)end function i:pop()return table.remove(self)end local n={}n.DefaultTable=e n.ListTable=t n.CharacterClass=a n.Tree=o n.Stack=i return n"}},require,loadstring or load _G.require=function(o,...)if e.loaded[o]then return e.loaded[o]elseif e.packages[o]then e.loaded[o]=a(e.packages[o])(...)return e.loaded[o]else return t(o)end end return require("__luapack_entry__",...)