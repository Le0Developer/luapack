
require_pattern = [[require *%(?["']([^"']+)["']%)?]]

-- imports
-- !!! using an extra function here, so the require call isn't interruped by a comma
--     and the minifier gets luapacked
minifier = select 2, try -> require "lib/minifier"
yue = select 2, try require "yue"
moon = select 2, try require "moonscript.base"

-- helpers
fast_push = (tbl, item) ->
    tbl[tbl.n + 1] = item
    tbl.n += 1

class Writer
    new: =>
        @dept = 0
        @out = {n: 0}
    
    indent: => "\t"\rep @dept

    writeln: (text) => fast_push @out, "#{@indent!}#{text}"
    writelines: (text) => @writeln line for line in text\gmatch "[^\n]+"
    
    incr: => @dept += 1
    decr: => @dept -= 1
    wrap: (cb) =>
        @incr!
        cb!
        @decr!
    endwrap: (cb) =>
        @wrap cb
        @writeln "end"

    str: => table.concat @out, "\n"

-- version info

export __author__ = "Leo Developer"
export __url__ = "https://github.com/le0developer/luapack"
export __license__ = "MIT"
export __version__ = "0.2.0"

export default_plugins = {n: 0}

-- api interface:
--   searchpath(packer, name)
--     returns nil/false or a path to a file
--   loader(packer, name, content)
--     post-processing of the file
--     return lua code

package_path_with_different_extension = => package.path\gsub "%.lua", ".#{@}"
check_file_extension = (filename, ext) -> ext == filename\sub -#ext

fast_push default_plugins,
    name: "lua"
    check_filename: (packer, filename) -> check_file_extension filename, ".lua"
    searchpath: (packer, name) -> packer\searchpath_compat name, package.path

if yue
    fast_push default_plugins,
        name: "yuescript"
        check_filename: (packer, filename) -> check_file_extension filename, ".yue"
        searchpath: (packer, name) -> packer\searchpath_compat name, package_path_with_different_extension "yue"
        loader: (packer, name, content) -> yue.to_lua content, reserve_line_number: false

if moon
    fast_push default_plugins,
        name: "moonscript"
        check_filename: (packer, filename) -> check_file_extension filename, ".moon"
        searchpath: (packer, name) -> packer\searchpath_compat name, package_path_with_different_extension "moon"
        loader: (packer, name, content) -> moon.to_lua content


-- packer class

-- options:
--   minify = true
--   package_polyfill = false
--   with_header = true
--   clear_loaded = true
--   plugins = default_plugins
export class Packer
    new: (@options = {}) =>
        @loaded = {}
    
    searchpath_compat: (name, path) =>
        package.searchpath name, path if package.searchpath -- lua 5.2+
        sep = ";" -- lua 5.1 didnt have package.config
        name = name\gsub "%.", "/" -- a.b.c -> a/b/c
        for path in path\gmatch "[^;]+"
            path = path\gsub "?", name
            -- very janky cross platform check to see if the file exists
            -- this janky check also somehow accepts directories
            -- because they can be opened??
            fh = io.open path, "r"
            if fh?
                fh\close!
                return path

    extract_packages: (source) =>
        matches = {n: 0}
        fast_push matches, match for match in source\gmatch require_pattern
        matches

    include: (package_name, filename) =>
        plugins = @options.plugins or default_plugins
        plugin_index = 1
        if filename?
            -- only the case for __luapack_entry__ or other manual files
            -- but we need to figure out the plugin
            while true
                plugin = plugins[plugin_index]
                return unless plugin? -- all plugins failed
                if plugin.check_filename?
                    break if plugin.check_filename @, filename -- found the responsible plugin
                plugin_index += 1

        while not filename?
            plugin = plugins[plugin_index]
            return unless plugin? -- all plugins failed
            if plugin.searchpath?
                filename = plugin.searchpath @, package_name
                break if filename? -- finally found the filename
            plugin_index += 1
        
        return unless filename?
        return if @loaded[package_name]? -- recursion
        -- return unless filename\match"%.lua$" -- not a lua file
        with fh = io.open filename, "r"
            error "file not found: #{filename}" unless fh?
            @loaded[package_name] = \read"*a"
            \close!
        return if "-- luapacked" == @loaded[package_name]\sub 1, 12 -- dont pack dependencies of a packed file
        if plugins[plugin_index].loader
            @loaded[package_name] = plugins[plugin_index].loader @, package_name, @loaded[package_name]
        @include dependency for dependency in *@extract_packages @loaded[package_name]

    pack: (entry) =>
        @include "__luapack_entry__", entry
        error "file not found: #{entry}" unless @loaded["__luapack_entry__"]?

        packed = @bootstrap!
        packed = minifier.Rebuild.MinifyString packed if @options.minify != false and minifier
        header = ""
        if @options.with_header != false
            header = "-- luapacked using #{__version__}\n"
        header .. packed

    bootstrap: =>
        writer = Writer!
        if @options.package_polyfill
            writer\writeln "if not package then _G.package = {preload = {}, loaded = {}} end"
            writer\writeln "if not package.preload then package.preload = {} end"
            writer\writeln "if not package.loaded then package.loaded = {} end"
            writer\writeln "if not require then"
            writer\endwrap ->
                writer\writeln "local sentinel = {}" -- recursion detection
                writer\writeln "_G.require = function(modname)"
                writer\endwrap ->
                    writer\writeln "if package.loaded[modname] == sentinel then"
                    writer\endwrap ->
                        writer\writeln 'error(("loop or previous error loading module %q"):format(modname), 0)'
                    writer\writeln "if package.loaded[modname] ~= nil then return package.loaded[name] end"
                    writer\writeln "if not package.preload[modname] then"
                    writer\endwrap ->
                        writer\writeln 'error(("module not found %q"):format(modname), 2)'
                    writer\writeln "package.loaded[modname] = sentinel"
                    writer\writeln "local result = package.preload[modname]()"
                    writer\writeln "if result == nil then result = true end"
                    writer\writeln "package.loaded[modname] = result"
                    writer\writeln "return result"

        already_loaded = {}
        for package_name, content in pairs @loaded
            if already_loaded[content]
                writer\writeln "package.preload[%q] = package.preload[%q]"\format package_name, already_loaded[content]
            else
                writer\writeln "package.preload[%q] = function(...)"\format package_name
                writer\endwrap ->
                    writer\writelines content
                already_loaded[content] = package_name
            if @options.clear_loaded != false
                writer\writeln "package.loaded[%q] = nil"\format package_name
        
        if @loaded["__luapack_entry__"]?
            -- some C functions may return "fake" nil which behave differently
            -- returning it crashes some environments
            -- assigning it to a variable fixes the issue
            --  TODO: do we need the `do` block?
            writer\writeln "do"
            writer\endwrap ->
                writer\writeln 'local _result = package.preload["__luapack_entry__"](...)'
                writer\writeln "return _result"
        writer\str!

-- cli
arguments = {...}
arguments.n = #arguments

-- "clever" cli detection
if arguments.n > 0 and not package.loaded[arguments[1]]? and not package.preload[arguments[1]]?
    -- user is using cli!
    options = {}
    for arg in *arguments
        continue if "-" != arg\sub 1, 1
        switch arg
            when "-no-header" then options.with_header = false
            when "-yes-header" then options.with_header = true
            when "-no-package-polyfill" then options.package_polyfill = false
            when "-yes-package-polyfill" then options.package_polyfill = true
            when "-no-minify" then options.minify = false
            when "-yes-minify" then options.minify = true

    print "Using luapack #{__version__}"
    print!
    for filename in *arguments
        continue if "-" == filename\sub 1, 1
        print "Packing #{filename}"
        packer = Packer options
        packed = packer\pack filename
        outfile = filename\gsub "%.(%a+)$", (x) -> ".packed.lua"
        print "Packed into #{outfile}"
        break if filename == outfile
        with io.open outfile, "w"
            \write packed
            \close!
